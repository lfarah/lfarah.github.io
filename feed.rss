<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Lucas Farah's Blog</title><description>Helping myself become a better developer</description><link>https://lfarah.github.io/blog/</link><language>en</language><lastBuildDate>Thu, 19 Dec 2024 09:48:58 -0300</lastBuildDate><pubDate>Thu, 19 Dec 2024 09:48:58 -0300</pubDate><ttl>250</ttl><atom:link href="https://lfarah.github.io/blog/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://lfarah.github.io/blog/collino/privacyPolicy</guid><title>privacyPolicy</title><description>Collino Privacy Policy</description><link>https://lfarah.github.io/blog/collino/privacyPolicy</link><pubDate>Thu, 19 Dec 2024 09:00:00 -0300</pubDate><content:encoded><![CDATA[<p><strong>Privacy Policy</strong></p><p>This privacy policy applies to the Collino app (hereby referred to as "Application") for mobile devices that was created by Lucas Farah Palmiro (hereby referred to as "Service Provider") as a Free service. This service is intended for use "AS IS".</p><p><strong>What information does the Application obtain and how is it used?</strong></p><p>The Application does not obtain any information when you download and use it. Registration is not required to use the Application.</p><p><strong>Does the Application collect precise real time location information of the device?</strong></p><p>This Application does not collect precise information about the location of your mobile device.</p><p><strong>Do third parties see and/or have access to information obtained by the Application?</strong></p><p>Since the Application does not collect any information, no data is shared with third parties.</p><p><strong>What are my opt-out rights?</strong></p><p>You can stop all collection of information by the Application easily by uninstalling it. You may use the standard uninstall processes as may be available as part of your mobile device or via the mobile application marketplace or network.</p><p><strong>Children</strong></p><p>The Application is not used to knowingly solicit data from or market to children under the age of 13.</p><p>The Service Provider does not knowingly collect personally identifiable information from children. The Service Provider encourages all children to never submit any personally identifiable information through the Application and/or Services. The Service Provider encourage parents and legal guardians to monitor their children's Internet usage and to help enforce this Policy by instructing their children never to provide personally identifiable information through the Application and/or Services without their permission. If you have reason to believe that a child has provided personally identifiable information to the Service Provider through the Application and/or Services, please contact the Service Provider (feedback@lucasfarah.dev) so that they will be able to take the necessary actions. You must also be at least 16 years of age to consent to the processing of your personally identifiable information in your country (in some countries we may allow your parent or guardian to do so on your behalf).</p><p><strong>Security</strong></p><p>The Service Provider is concerned about safeguarding the confidentiality of your information. However, since the Application does not collect any information, there is no risk of your data being accessed by unauthorized individuals.</p><p><strong>Changes</strong></p><p>This Privacy Policy may be updated from time to time for any reason. The Service Provider will notify you of any changes to their Privacy Policy by updating this page with the new Privacy Policy. You are advised to consult this Privacy Policy regularly for any changes, as continued use is deemed approval of all changes.</p><p>This privacy policy is effective as of 2024-12-19</p><p><strong>Your Consent</strong></p><p>By using the Application, you are consenting to the processing of your information as set forth in this Privacy Policy now and as amended by the Service Provider.</p><p><strong>Contact Us</strong></p><p>If you have any questions regarding privacy while using the Application, or have questions about the practices, please contact the Service Provider via email at feedback@lucasfarah.dev.</p><ul><li><em> </em></li></ul><p>This privacy policy page was generated by <a href="https://app-privacy-policy-generator.nisrulz.com/">App Privacy Policy Generator</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://lfarah.github.io/blog/collino/privacyPolicy</guid><title>privacyPolicy</title><description>Collino Privacy Policy</description><link>https://lfarah.github.io/blog/collino/privacyPolicy</link><pubDate>Thu, 19 Dec 2024 09:00:00 -0300</pubDate><content:encoded><![CDATA[<p><strong>Privacy Policy</strong></p><p>This privacy policy applies to the Collino app (hereby referred to as "Application") for mobile devices that was created by Lucas Farah Palmiro (hereby referred to as "Service Provider") as a Free service. This service is intended for use "AS IS".</p><p><strong>What information does the Application obtain and how is it used?</strong></p><p>The Application does not obtain any information when you download and use it. Registration is not required to use the Application.</p><p><strong>Does the Application collect precise real time location information of the device?</strong></p><p>This Application does not collect precise information about the location of your mobile device.</p><p><strong>Do third parties see and/or have access to information obtained by the Application?</strong></p><p>Since the Application does not collect any information, no data is shared with third parties.</p><p><strong>What are my opt-out rights?</strong></p><p>You can stop all collection of information by the Application easily by uninstalling it. You may use the standard uninstall processes as may be available as part of your mobile device or via the mobile application marketplace or network.</p><p><strong>Children</strong></p><p>The Application is not used to knowingly solicit data from or market to children under the age of 13.</p><p>The Service Provider does not knowingly collect personally identifiable information from children. The Service Provider encourages all children to never submit any personally identifiable information through the Application and/or Services. The Service Provider encourage parents and legal guardians to monitor their children's Internet usage and to help enforce this Policy by instructing their children never to provide personally identifiable information through the Application and/or Services without their permission. If you have reason to believe that a child has provided personally identifiable information to the Service Provider through the Application and/or Services, please contact the Service Provider (feedback@lucasfarah.dev) so that they will be able to take the necessary actions. You must also be at least 16 years of age to consent to the processing of your personally identifiable information in your country (in some countries we may allow your parent or guardian to do so on your behalf).</p><p><strong>Security</strong></p><p>The Service Provider is concerned about safeguarding the confidentiality of your information. However, since the Application does not collect any information, there is no risk of your data being accessed by unauthorized individuals.</p><p><strong>Changes</strong></p><p>This Privacy Policy may be updated from time to time for any reason. The Service Provider will notify you of any changes to their Privacy Policy by updating this page with the new Privacy Policy. You are advised to consult this Privacy Policy regularly for any changes, as continued use is deemed approval of all changes.</p><p>This privacy policy is effective as of 2024-12-19</p><p><strong>Your Consent</strong></p><p>By using the Application, you are consenting to the processing of your information as set forth in this Privacy Policy now and as amended by the Service Provider.</p><p><strong>Contact Us</strong></p><p>If you have any questions regarding privacy while using the Application, or have questions about the practices, please contact the Service Provider via email at feedback@lucasfarah.dev.</p><ul><li><em> </em></li></ul><p>This privacy policy page was generated by <a href="https://app-privacy-policy-generator.nisrulz.com/">App Privacy Policy Generator</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://lfarah.github.io/blog/articles/custom-swiftlint-rules</guid><title>Using custom Swiftlint rules</title><description>Enforcing code style</description><link>https://lfarah.github.io/blog/articles/custom-swiftlint-rules</link><pubDate>Sat, 6 Feb 2021 11:39:00 -0300</pubDate><content:encoded><![CDATA[<h1>Using custom Swiftlint rules</h1><p>Swiftlint is an amazing tool that help us not only write cleaner code, but also better code. Thanks to Swiftlint, I once got a job because my code was clean. Thanks to Swiftlint, I learned that delegates should be class protocols and weak.</p><h3>Enforcing Extensions</h3><p>Extensions are one of my favorite features of the Swift language. They are really helpful to add tricks to current classes, avoiding those huge “Utils” files we see in many projects. One problem though, when working on a team bigger than 1 developer, is to remember these extensions exist and we end up creating our own extensions or doing it in the “old”, uglier way. Let’s take for example my favorite extensions:</p><pre><code><span class="keyword">extension</span> <span class="type">UITableViewCell</span> {
    
    <span class="keyword">static var</span> reuseIdentifier: <span class="type">String</span> {
        <span class="keyword">return</span> <span class="type">NSStringFromClass</span>(<span class="keyword">self</span>)
    }
}

<span class="keyword">extension</span> <span class="type">UITableView</span> {
    
    <span class="keyword">public func</span> register&lt;T: <span class="type">UITableViewCell</span>&gt;(type: <span class="type">T</span>.<span class="type">Type</span>) {
        <span class="call">register</span>(type, forCellReuseIdentifier: type.<span class="property">reuseIdentifier</span>)
    }
    
    <span class="keyword">public func</span> dequeue&lt;T: <span class="type">UITableViewCell</span>&gt;(type: <span class="type">T</span>.<span class="type">Type</span>, indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">T</span> {
        <span class="keyword">guard let</span> cell = <span class="call">dequeueReusableCell</span>(withIdentifier: type.<span class="property">reuseIdentifier</span>, for: indexPath) <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> {
            <span class="call">fatalError</span>(<span class="string">"Cell not registered:</span> \(<span class="type">T</span>.<span class="keyword">self</span>)<span class="string">"</span>)
        }
        <span class="keyword">return</span> cell
    }
}
</code></pre><p>Thanks to this extension and the power of generics, we can reduce a lot of boilerplate:</p><pre><code><span class="comment">// Old</span>

<span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    tableView.<span class="call">register</span>(<span class="type">NameCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"NameCell"</span>)
}

<span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">guard let</span> cell = tableView.<span class="call">dequeueReusableCell</span>(withIdentifier: <span class="string">"NameCell"</span>, for: indexPath) <span class="keyword">as</span>? <span class="type">NameCell</span> <span class="keyword">else</span> {
        <span class="call">fatalError</span>(<span class="string">"Name cell not registered"</span>)
    }
    cell.<span class="property">name</span> = <span class="string">""</span>
    
    <span class="keyword">return</span> cell
}
</code></pre><pre><code><span class="comment">// New</span>
<span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    tableView.<span class="call">register</span>(type: <span class="type">NameCell</span>.<span class="keyword">self</span>)
}

<span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">let</span> cell = tableView.<span class="call">dequeue</span>(type: <span class="type">NameCell</span>.<span class="keyword">self</span>, indexPath: indexPath)
    cell.<span class="property">name</span> = <span class="string">""</span>
    <span class="keyword">return</span> cell
}
</code></pre><p>One problem though, is that the new developer that just arrived in my team doesn’t know about these extensions, so there’s a great chance that the developer will open a PR using the regular methods instead of our shiny extension.</p><h5>Custom lint rules to the rescue!</h5><p>We can create a rule that detects when the developer is using the regular method and presents a warning teaching the dev about our amazing extension. Swiftlint rules are all based on Regex, so I’ve been using [Regex website] to help me out while writing our regex.</p><pre><code><span class="comment">// .swiftlint.yml</span>
custom_rules:
  tableview_register_extension:
    included: <span class="string">".*\\.swift"</span>
    excluded: <span class="string">".*\\Extensions.swift"</span>
    name: <span class="string">"TableView Register Extension"</span>
    regex: <span class="string">"(register).*(forCellReuseIdentifier)"</span>
    message: <span class="string">"Please use our extension instead: tableView.register(type: CellClass.self)"</span>
    severity: warning
    
  tableview_dequeue_extension:\
    included: <span class="string">".*\\.swift"</span>
    excluded: <span class="string">".*\\Extensions.swift"</span>\
    name: <span class="string">"TableView Dequeue Extension"</span>
    regex: <span class="string">"(dequeueReusableCell\</span>\(withIdentifier)<span class="string">"</span>
    message: <span class="string">"Please use our extension instead: dequeue(type: CellClass.self, indexPath: indexPath)"</span>
    severity: warning
</code></pre><img src="https://lfarah.github.io/blog//images/custom-swiftlint-rules/table-register-warning.png" alt="Table Register Warning" width="800"/><img src="https://lfarah.github.io/blog//images/custom-swiftlint-rules/table-dequeue-warning.png" alt="Table Dequeue Warning" width="800"/><h3>Enforcing a design pattern</h3><p>At one of my previous companies, we were using MVVM + Repository with a separate framework for the API. So one idea we had to enforce our design pattern was to only allow the Repository classes to import API.</p><pre><code>api_outside_repository:
  included: <span class="string">".*\\.swift"</span>
  excluded: <span class="string">".*\\Repository.swift"</span>
  name: <span class="string">"Import API outside Repository"</span>
  regex: <span class="string">"(import API)"</span>
  message: <span class="string">"Only Repository classes can import API"</span>
  severity: warning
</code></pre><p>Another of our projects used Coordinators, so we created another rule to enforce that no ViewController was presenting another ViewController</p><pre><code>

present_outside_coordinator:
  included: <span class="string">".*\\.swift"</span>
  excluded: <span class="string">".*\\Coordinator.swift"</span>
  name: <span class="string">"Use present outside Coordinator"</span>
  regex: <span class="string">"(present).*(animated)"</span>
  message: <span class="string">"Only Coordinators can present ViewControllers"</span>
  severity: warning
</code></pre><h3>Magic number in constraints</h3><p>Views can become quite complex, so organizing our constraints was also really important for our team. We created a rule to avoid magic numbers in constraints, asking the dev to use a constant that was defined somewhere else in the code.</p><pre><code><span class="comment">// Lint rule</span> 
</code></pre><h3>Conclusion</h3><p>These are some examples, but sky is the limit. The important thing when introducing these rules is to discuss with your team. Swiftlint should be your helper, not a dictator.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lfarah.github.io/blog/articles/custom-swiftlint-rules</guid><title>Using custom Swiftlint rules</title><description>Enforcing code style</description><link>https://lfarah.github.io/blog/articles/custom-swiftlint-rules</link><pubDate>Sat, 6 Feb 2021 11:39:00 -0300</pubDate><content:encoded><![CDATA[<h1>Using custom Swiftlint rules</h1><p>Swiftlint is an amazing tool that help us not only write cleaner code, but also better code. Thanks to Swiftlint, I once got a job because my code was clean. Thanks to Swiftlint, I learned that delegates should be class protocols and weak.</p><h3>Enforcing Extensions</h3><p>Extensions are one of my favorite features of the Swift language. They are really helpful to add tricks to current classes, avoiding those huge “Utils” files we see in many projects. One problem though, when working on a team bigger than 1 developer, is to remember these extensions exist and we end up creating our own extensions or doing it in the “old”, uglier way. Let’s take for example my favorite extensions:</p><pre><code><span class="keyword">extension</span> <span class="type">UITableViewCell</span> {
    
    <span class="keyword">static var</span> reuseIdentifier: <span class="type">String</span> {
        <span class="keyword">return</span> <span class="type">NSStringFromClass</span>(<span class="keyword">self</span>)
    }
}

<span class="keyword">extension</span> <span class="type">UITableView</span> {
    
    <span class="keyword">public func</span> register&lt;T: <span class="type">UITableViewCell</span>&gt;(type: <span class="type">T</span>.<span class="type">Type</span>) {
        <span class="call">register</span>(type, forCellReuseIdentifier: type.<span class="property">reuseIdentifier</span>)
    }
    
    <span class="keyword">public func</span> dequeue&lt;T: <span class="type">UITableViewCell</span>&gt;(type: <span class="type">T</span>.<span class="type">Type</span>, indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">T</span> {
        <span class="keyword">guard let</span> cell = <span class="call">dequeueReusableCell</span>(withIdentifier: type.<span class="property">reuseIdentifier</span>, for: indexPath) <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> {
            <span class="call">fatalError</span>(<span class="string">"Cell not registered:</span> \(<span class="type">T</span>.<span class="keyword">self</span>)<span class="string">"</span>)
        }
        <span class="keyword">return</span> cell
    }
}
</code></pre><p>Thanks to this extension and the power of generics, we can reduce a lot of boilerplate:</p><pre><code><span class="comment">// Old</span>

<span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    tableView.<span class="call">register</span>(<span class="type">NameCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"NameCell"</span>)
}

<span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">guard let</span> cell = tableView.<span class="call">dequeueReusableCell</span>(withIdentifier: <span class="string">"NameCell"</span>, for: indexPath) <span class="keyword">as</span>? <span class="type">NameCell</span> <span class="keyword">else</span> {
        <span class="call">fatalError</span>(<span class="string">"Name cell not registered"</span>)
    }
    cell.<span class="property">name</span> = <span class="string">""</span>
    
    <span class="keyword">return</span> cell
}
</code></pre><pre><code><span class="comment">// New</span>
<span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    tableView.<span class="call">register</span>(type: <span class="type">NameCell</span>.<span class="keyword">self</span>)
}

<span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">let</span> cell = tableView.<span class="call">dequeue</span>(type: <span class="type">NameCell</span>.<span class="keyword">self</span>, indexPath: indexPath)
    cell.<span class="property">name</span> = <span class="string">""</span>
    <span class="keyword">return</span> cell
}
</code></pre><p>One problem though, is that the new developer that just arrived in my team doesn’t know about these extensions, so there’s a great chance that the developer will open a PR using the regular methods instead of our shiny extension.</p><h5>Custom lint rules to the rescue!</h5><p>We can create a rule that detects when the developer is using the regular method and presents a warning teaching the dev about our amazing extension. Swiftlint rules are all based on Regex, so I’ve been using [Regex website] to help me out while writing our regex.</p><pre><code><span class="comment">// .swiftlint.yml</span>
custom_rules:
  tableview_register_extension:
    included: <span class="string">".*\\.swift"</span>
    excluded: <span class="string">".*\\Extensions.swift"</span>
    name: <span class="string">"TableView Register Extension"</span>
    regex: <span class="string">"(register).*(forCellReuseIdentifier)"</span>
    message: <span class="string">"Please use our extension instead: tableView.register(type: CellClass.self)"</span>
    severity: warning
    
  tableview_dequeue_extension:\
    included: <span class="string">".*\\.swift"</span>
    excluded: <span class="string">".*\\Extensions.swift"</span>\
    name: <span class="string">"TableView Dequeue Extension"</span>
    regex: <span class="string">"(dequeueReusableCell\</span>\(withIdentifier)<span class="string">"</span>
    message: <span class="string">"Please use our extension instead: dequeue(type: CellClass.self, indexPath: indexPath)"</span>
    severity: warning
</code></pre><img src="https://lfarah.github.io/blog//images/custom-swiftlint-rules/table-register-warning.png" alt="Table Register Warning" width="800"/><img src="https://lfarah.github.io/blog//images/custom-swiftlint-rules/table-dequeue-warning.png" alt="Table Dequeue Warning" width="800"/><h3>Enforcing a design pattern</h3><p>At one of my previous companies, we were using MVVM + Repository with a separate framework for the API. So one idea we had to enforce our design pattern was to only allow the Repository classes to import API.</p><pre><code>api_outside_repository:
  included: <span class="string">".*\\.swift"</span>
  excluded: <span class="string">".*\\Repository.swift"</span>
  name: <span class="string">"Import API outside Repository"</span>
  regex: <span class="string">"(import API)"</span>
  message: <span class="string">"Only Repository classes can import API"</span>
  severity: warning
</code></pre><p>Another of our projects used Coordinators, so we created another rule to enforce that no ViewController was presenting another ViewController</p><pre><code>

present_outside_coordinator:
  included: <span class="string">".*\\.swift"</span>
  excluded: <span class="string">".*\\Coordinator.swift"</span>
  name: <span class="string">"Use present outside Coordinator"</span>
  regex: <span class="string">"(present).*(animated)"</span>
  message: <span class="string">"Only Coordinators can present ViewControllers"</span>
  severity: warning
</code></pre><h3>Magic number in constraints</h3><p>Views can become quite complex, so organizing our constraints was also really important for our team. We created a rule to avoid magic numbers in constraints, asking the dev to use a constant that was defined somewhere else in the code.</p><pre><code><span class="comment">// Lint rule</span> 
</code></pre><h3>Conclusion</h3><p>These are some examples, but sky is the limit. The important thing when introducing these rules is to discuss with your team. Swiftlint should be your helper, not a dictator.</p>]]></content:encoded></item></channel></rss>